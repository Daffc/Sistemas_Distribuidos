<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_l8uuvtic5ori-0{list-style-type:none}ul.lst-kix_l8uuvtic5ori-1{list-style-type:none}ul.lst-kix_m6ttgladw357-8{list-style-type:none}ul.lst-kix_l8uuvtic5ori-2{list-style-type:none}ul.lst-kix_m6ttgladw357-7{list-style-type:none}ul.lst-kix_l8uuvtic5ori-3{list-style-type:none}.lst-kix_m6ttgladw357-3>li:before{content:"\0025cf  "}.lst-kix_m6ttgladw357-5>li:before{content:"\0025a0  "}ul.lst-kix_m6ttgladw357-6{list-style-type:none}ul.lst-kix_m6ttgladw357-5{list-style-type:none}ul.lst-kix_m6ttgladw357-4{list-style-type:none}ul.lst-kix_m6ttgladw357-3{list-style-type:none}.lst-kix_m6ttgladw357-0>li:before{content:"\0025cf  "}ul.lst-kix_m6ttgladw357-2{list-style-type:none}.lst-kix_m6ttgladw357-4>li:before{content:"\0025cb  "}ul.lst-kix_l8uuvtic5ori-8{list-style-type:none}.lst-kix_m6ttgladw357-7>li:before{content:"\0025cb  "}ul.lst-kix_l8uuvtic5ori-4{list-style-type:none}ul.lst-kix_l8uuvtic5ori-5{list-style-type:none}.lst-kix_42jfxxe660of-4>li:before{content:"\0025cb  "}ul.lst-kix_l8uuvtic5ori-6{list-style-type:none}.lst-kix_fo9qop3tgxxw-0>li:before{content:"\0025cf  "}ul.lst-kix_l8uuvtic5ori-7{list-style-type:none}.lst-kix_m6ttgladw357-6>li:before{content:"\0025cf  "}.lst-kix_fo9qop3tgxxw-3>li:before{content:"\0025cf  "}.lst-kix_fo9qop3tgxxw-1>li:before{content:"\0025cb  "}.lst-kix_fo9qop3tgxxw-5>li:before{content:"\0025a0  "}.lst-kix_42jfxxe660of-3>li:before{content:"\0025cf  "}.lst-kix_fo9qop3tgxxw-2>li:before{content:"\0025a0  "}.lst-kix_fo9qop3tgxxw-6>li:before{content:"\0025cf  "}.lst-kix_m6ttgladw357-8>li:before{content:"\0025a0  "}ul.lst-kix_m6ttgladw357-1{list-style-type:none}ul.lst-kix_42jfxxe660of-5{list-style-type:none}ul.lst-kix_m6ttgladw357-0{list-style-type:none}.lst-kix_42jfxxe660of-1>li:before{content:"\0025cb  "}.lst-kix_42jfxxe660of-2>li:before{content:"\0025a0  "}ul.lst-kix_42jfxxe660of-6{list-style-type:none}ul.lst-kix_42jfxxe660of-7{list-style-type:none}ul.lst-kix_42jfxxe660of-8{list-style-type:none}.lst-kix_42jfxxe660of-0>li:before{content:"\0025cf  "}.lst-kix_fo9qop3tgxxw-4>li:before{content:"\0025cb  "}ul.lst-kix_42jfxxe660of-0{list-style-type:none}ul.lst-kix_42jfxxe660of-1{list-style-type:none}ul.lst-kix_42jfxxe660of-2{list-style-type:none}ul.lst-kix_42jfxxe660of-3{list-style-type:none}ul.lst-kix_42jfxxe660of-4{list-style-type:none}.lst-kix_fo9qop3tgxxw-7>li:before{content:"\0025cb  "}.lst-kix_fo9qop3tgxxw-8>li:before{content:"\0025a0  "}.lst-kix_m6ttgladw357-1>li:before{content:"\0025cb  "}.lst-kix_m6ttgladw357-2>li:before{content:"\0025a0  "}ul.lst-kix_fo9qop3tgxxw-7{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-6{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-8{list-style-type:none}.lst-kix_5234d5od5pbe-7>li:before{content:"\0025cb  "}ul.lst-kix_fo9qop3tgxxw-3{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-2{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-5{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-4{list-style-type:none}.lst-kix_5234d5od5pbe-8>li:before{content:"\0025a0  "}ul.lst-kix_fo9qop3tgxxw-1{list-style-type:none}ul.lst-kix_fo9qop3tgxxw-0{list-style-type:none}.lst-kix_5234d5od5pbe-3>li:before{content:"\0025cf  "}.lst-kix_5234d5od5pbe-2>li:before{content:"\0025a0  "}.lst-kix_5234d5od5pbe-6>li:before{content:"\0025cf  "}.lst-kix_5234d5od5pbe-5>li:before{content:"\0025a0  "}.lst-kix_5234d5od5pbe-4>li:before{content:"\0025cb  "}.lst-kix_l8uuvtic5ori-0>li:before{content:"\0025cf  "}.lst-kix_l8uuvtic5ori-3>li:before{content:"\0025cf  "}.lst-kix_5234d5od5pbe-1>li:before{content:"\0025cb  "}.lst-kix_l8uuvtic5ori-2>li:before{content:"\0025a0  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_5234d5od5pbe-0>li:before{content:"\0025cf  "}.lst-kix_l8uuvtic5ori-1>li:before{content:"\0025cb  "}.lst-kix_l8uuvtic5ori-8>li:before{content:"\0025a0  "}ul.lst-kix_5234d5od5pbe-0{list-style-type:none}.lst-kix_42jfxxe660of-5>li:before{content:"\0025a0  "}.lst-kix_42jfxxe660of-6>li:before{content:"\0025cf  "}ul.lst-kix_5234d5od5pbe-1{list-style-type:none}ul.lst-kix_5234d5od5pbe-2{list-style-type:none}ul.lst-kix_5234d5od5pbe-3{list-style-type:none}ul.lst-kix_5234d5od5pbe-4{list-style-type:none}.lst-kix_42jfxxe660of-7>li:before{content:"\0025cb  "}ul.lst-kix_5234d5od5pbe-5{list-style-type:none}.lst-kix_l8uuvtic5ori-7>li:before{content:"\0025cb  "}ul.lst-kix_5234d5od5pbe-6{list-style-type:none}ul.lst-kix_5234d5od5pbe-7{list-style-type:none}.lst-kix_l8uuvtic5ori-4>li:before{content:"\0025cb  "}ul.lst-kix_5234d5od5pbe-8{list-style-type:none}.lst-kix_l8uuvtic5ori-6>li:before{content:"\0025cf  "}.lst-kix_42jfxxe660of-8>li:before{content:"\0025a0  "}.lst-kix_l8uuvtic5ori-5>li:before{content:"\0025a0  "}ol{margin:0;padding:0}table td,table th{padding:0}.c25{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:507pt;border-top-color:#000000;border-bottom-style:solid}.c1{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center;height:11pt}.c28{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Arial";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;height:11pt}.c24{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c21{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c19{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c23{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c31{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial"}.c22{margin-left:-28.5pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c27{background-color:#ffffff;max-width:453.5pt;padding:85pt 56.7pt 56.7pt 85pt}.c11{padding:0;margin:0}.c6{font-size:10pt;font-style:italic}.c7{margin-left:108pt}.c15{padding-left:0pt}.c16{margin-left:72pt}.c18{font-weight:700}.c8{font-size:10pt}.c17{font-size:26pt}.c30{height:11pt}.c13{text-indent:36pt}.c9{font-style:italic}.c29{height:0pt}.c20{font-size:16pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c27"><p class="c1 title" id="h.cyq378tjpiz3"><span class="c14 c17"></span></p><p class="c1 title" id="h.wrhonpza4rc0"><span class="c14 c17"></span></p><p class="c1 title" id="h.pkdoj0gicamo"><span class="c14 c17"></span></p><p class="c1 title" id="h.fqpg0vz51jzk"><span class="c14 c17"></span></p><p class="c31 title" id="h.1e1mwdebpmpp"><span class="c14 c17">Relat&oacute;rio de Simula&ccedil;&atilde;o de Algoritmo Distribu&iacute;do VCube Sobre Simulador SMPL.</span></p><p class="c2"><span class="c12"></span></p><p class="c4"><span class="c12"></span></p><p class="c4"><span class="c12"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c5"><span class="c10">Douglas Affonso Clementino - GRR20175877</span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c4"><span class="c10"></span></p><p class="c5"><span class="c10">13/07/2021</span></p><h2 class="c24" id="h.83vpa4qkvrhv"><span class="c14 c20">Decis&otilde;es Tomadas:</span></h2><p class="c2"><span class="c12"></span></p><p class="c3 c13"><span class="c12">Foi utilizada a biblioteca &lsquo;cisj.c&rsquo; disponibilizada por professor para c&aacute;lculo cisj. A fun&ccedil;&atilde;o principal (main) foi devidamente modificada para receber os mesmos par&acirc;metros anteriores (c, i, s e j) al&eacute;m do par&acirc;metro adicional &lsquo;ret&rsquo;, que &eacute; um ponteiro para uma lista de inteiros. Onde anteriormente eram impressos os elementos do cluster solicitado, agora estes s&atilde;o devidamente armazenados em vetor &lsquo;ret&rsquo;. Ao final retorna-se a quantidade de elementos solicitados.</span></p><p class="c2 c13"><span class="c12"></span></p><p class="c3 c13"><span>Foi definido arquivo de cabe&ccedil;alhos &lsquo;nodo.h&rsquo; de forma que estrutura </span><span class="c9">tnodo</span><span>&nbsp;(que descreve os nodos utilizados na simula&ccedil;&atilde;o) pudesse estar dispon&iacute;vel para m&uacute;ltiplos arquivos fontes. Estrutura </span><span class="c9">tnodo</span><span>&nbsp;&eacute; utilizada para armazenar id de nodo, Vector State de </span><span>nodo</span><span>&nbsp;(state), vetor de testes que </span><span>nodo</span><span class="c12">&nbsp;dever&aacute; realizar (testes) e quantidade de testes que devem ser realizados pelo nodo (qnt_testes).</span></p><p class="c2 c13"><span class="c12"></span></p><p class="c3 c13"><span class="c12">Foram definidos os arquivos &lsquo;evento.c&rsquo; e &lsquo;evento.h&rsquo; para o controle dos eventos que ocorram durante a simula&ccedil;&atilde;o, fazendo o controle das informa&ccedil;&otilde;es de eventos que venham a ocorrer, assim como os seus diagn&oacute;sticos. Importante ressaltar que l&oacute;gica de controle de eventos est&aacute; de acordo com a especifica&ccedil;&atilde;o de trabalho (apenas um evento deve ocorrer at&eacute; que seu diagn&oacute;stico seja efetuado), dessa forma, garante-se apenas o pleno diagn&oacute;stico de eventos que n&atilde;o se sobreponham.</span></p><p class="c2 c13"><span class="c12"></span></p><p class="c3 c13"><span class="c12">Como fluxo principal, &eacute; utilizado o arquivo &lsquo;trabPrat.c&rsquo;, onde est&aacute; contido o fluxo principal para execu&ccedil;&atilde;o da simula&ccedil;&atilde;o.</span></p><p class="c2 c13"><span class="c12"></span></p><p class="c3 c13"><span>A fim de determinar os testadores de um nodo, considerando o nodo </span><span class="c9">i</span><span>&nbsp;caso a entrada </span><span class="c9">j</span><span>&nbsp;de seu Vector State contenha valor DESCONHECIDO (-1) considera-se o nodo </span><span class="c9">j</span><span>&nbsp;CORRETO.</span><hr style="page-break-before:always;display:none;"></p><h2 class="c24" id="h.i66nvy3xxclx"><span class="c14 c20">Funcionamento Do Algoritmo</span></h2><p class="c2"><span class="c12"></span></p><h3 class="c28" id="h.i3xt6dsuymx4"><span>Inicializa&ccedil;&otilde;es de Simula&ccedil;&atilde;o</span></h3><p class="c2"><span class="c12"></span></p><p class="c3 c13"><span class="c12">Inicialmente recupera-se de entrada padr&atilde;o a quantidade de nodos que deseja-se simular, de forma que sejam armazenadas esta quantidade de estruturas tnodo, que efetuar&atilde;o o controle das informa&ccedil;&otilde;es de estado, Vector State e testes que ser&atilde;o realizados por cada um dos nodos.</span></p><p class="c3 c13"><span class="c12">Efetua-se ent&atilde;o a defini&ccedil;&atilde;o da quantidade de fluxos de simula&ccedil;&atilde;o, nome de simula&ccedil;&atilde;o e inicializa&ccedil;&atilde;o relacionados ao simulador smpl.</span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inicializa-se ent&atilde;o o Vector State de cada um dos nodos, de forma que para entrada com seu pr&oacute;prio identificador o valor seja 0 (correto) e as demais entradas constem com o valor de estado desconhecido (-1).</span></p><p class="c3"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ap&oacute;s isso inicializa uma vari&aacute;vel da estrutura </span><span class="c9">tevento</span><span class="c12">, alocando espa&ccedil;o necess&aacute;rio para controle de eventos e sinalizando em flag &lsquo;diagnosticando = 0&rsquo;, ou seja, que nenhum evento est&aacute; sendo diagnosticado.</span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Em seguida, todos os nodos s&atilde;o escalados para efetuarem teste em tempo 30.0 do tempo de simula&ccedil;&atilde;o. </span></p><p class="c3 c13"><span>Al&eacute;m disso, para cada um dos nodos &eacute; chamada a fun&ccedil;&atilde;o </span><span>&lsquo;defineTestes()&rsquo;,</span><span>&nbsp;que ir&aacute; calcular para cada um deles os testes que estes dever&atilde;o realizar. Pseudoc&oacute;digo para &#39;definir Testes()&#39; segue como:</span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><a id="t.0d92df32e13191c48e4462b9cd7f8bdd46ca2da0"></a><a id="t.0"></a><table class="c22"><tbody><tr class="c29"><td class="c25" colspan="1" rowspan="1"><p class="c0"><span class="c8">Algoritmo </span><span class="c18 c8">defineTestes</span><span class="c8">&nbsp;executado para nodo </span><span class="c26 c6">id</span></p><p class="c0 c30"><span class="c14 c8"></span></p><p class="c0"><span class="c8">&nbsp; &nbsp; clusters = </span><img src="log.png"><span class="c8">&nbsp; &nbsp; // Somar 1 busca explorar clusters incompletos, onde </span><span class="c6">N </span><span class="c14 c8">n&atilde;o &eacute; pot&ecirc;ncia de 2.</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c8 c18">for </span><span class="c6">s </span><span class="c14 c8">&nbsp;in clusters:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">for </span><span class="c6">i</span><span class="c8">&nbsp;in </span><span class="c6">N</span><span class="c14 c8">:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">if </span><span class="c6">i</span><span class="c8">&nbsp;!= </span><span class="c6">id</span><span class="c14 c8">:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recuperar lista ordenada de </span><span class="c6">testadores</span><span class="c8">&nbsp;de nodo </span><span class="c6">i</span><span class="c8">&nbsp; em cluster </span><span class="c6">s</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">for </span><span class="c6">j </span><span class="c8">in </span><span class="c6">testadores</span><span class="c14 c8">:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">if </span><span class="c14 c8">j &lt; N and nodo[id].VectorState[j] == CORRETO:</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">if</span><span class="c8">&nbsp;</span><span class="c6">j</span><span class="c8">&nbsp;== </span><span class="c6">id</span><span class="c8">: &nbsp; &nbsp; &nbsp; // Ou seja, se </span><span class="c6">id</span><span class="c8">&nbsp;for o primeiro testador v&aacute;lido de </span><span class="c6 c26">i</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Adiciona </span><span class="c6">i</span><span class="c8">&nbsp;a vetor de testes de </span><span class="c6">id</span></p><p class="c0"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c18 c8">break</span><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// nodo </span><span class="c6">j</span><span class="c8">&nbsp;v&aacute;lido</span><span class="c8">&nbsp;&eacute; primeiro a testar </span><span class="c6">i</span><span class="c8">&nbsp;em cluster </span><span class="c6">s</span><span class="c14 c8">, pular loos em cluster atual.</span></p></td></tr></tbody></table><p class="c2"><span class="c12"></span></p><p class="c3 c13"><span>Ap&oacute;s isso, eventos que ser&atilde;o realizados durante simula&ccedil;&atilde;o (Falhar/Recupera&ccedil;&atilde;o) s&atilde;o definidos em fun&ccedil;&atilde;o </span><span>&lsquo;agendarEventos()&rsquo;</span><span class="c12">&nbsp;para cada um dos nodos.</span></p><p class="c3 c13"><span class="c12">Finalmente, imprime-se em log informa&ccedil;&otilde;es sobre o estado inicial de cada um dos nodos, incluindo id, estado inicial e estados iniciais de vetor de testes e Vector State.</span></p><p class="c3 c13"><span>Ap&oacute;s isso, inicializa-se o loop de simula&ccedil;&atilde;o.</span><hr style="page-break-before:always;display:none;"></p><h3 class="c28" id="h.wuw2iaj66ywu"><span class="c23">Simula&ccedil;&atilde;o</span></h3><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A esta altura, ser&aacute; efetuado loop sobre eventos que foram previamente estipulado e que ser&atilde;o estipulados durante a simula&ccedil;&atilde;o, s&atilde;o eles FAULT, REPAIR e TEST.</span></p><p class="c2"><span class="c12"></span></p><h4 class="c19" id="h.udt6wjvk21nv"><span class="c21">FAULT</span></h4><p class="c3"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sendo </span><span class="c9">i </span><span>o</span><span>&nbsp;identificador do nodo que sofre o evento de FAULT, chama-se a fun&ccedil;&atilde;o &lsquo;request&rsquo; de API smlp buscando o cancelamento de nodo </span><span class="c9">i</span><span>, caso a opera&ccedil;&atilde;o seja mal sucedida, informa-se em log. Caso a opera&ccedil;&atilde;o ocorra sem problemas, &eacute; informado que </span><span>nodo </span><span class="c9">i</span><span class="c12">&nbsp;falhou.</span></p><p class="c3 c13"><span>Chama-se fun&ccedil;&atilde;o </span><span>&lsquo;inicializaNovoEvento()&rsquo;,</span><span>&nbsp;que atualizar&aacute; vari&aacute;vel de estrutura </span><span class="c9">tevento</span><span>,</span><span class="c12">&nbsp;indicando que um novo evento ocorreu e atualizando as informa&ccedil;&otilde;es:</span></p><ul class="c11 lst-kix_5234d5od5pbe-0 start"><li class="c3 c15 c16 li-bullet-0"><span class="c12">Nodo em que evento ocorreu.</span></li><li class="c3 c15 c16 li-bullet-0"><span class="c12">Tipo do evento (falha).</span></li><li class="c3 c15 c16 li-bullet-0"><span class="c12">Tempo em que o evento ocorreu. </span></li><li class="c3 c15 c16 li-bullet-0"><span class="c12">Reinicializa-se contador de rodadas.</span></li><li class="c3 c15 c16 li-bullet-0"><span class="c12">Reinicializa-se contador de testes.</span></li><li class="c3 c15 c16 li-bullet-0"><span>Atualiza </span><span>vetor</span><span>&nbsp;&lsquo;alertados&rsquo;, indicando que apenas nodo </span><span class="c9">i</span><span class="c12">&nbsp;sabe sobre evento.</span></li><li class="c3 c15 c16 li-bullet-0"><span>Atualiza vetor </span><span>&lsquo;rodada_completa&rsquo;,</span><span class="c12">&nbsp;indicando que todos os vetores FALHOS completaram suas rodadas, e os CORRETOS n&atilde;o completaram.</span></li><li class="c3 c15 c16 li-bullet-0"><span class="c12">Sinaliza em flag &lsquo;diagnosticando&rsquo; que existe novo evento a ser diagnosticado.</span></li></ul><p class="c2"><span class="c12"></span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assim, a l&oacute;gica para FAULT &eacute; completa, indo para o pr&oacute;ximo evento programado.</span></p><p class="c2"><span class="c12"></span></p><h4 class="c19" id="h.r5603x1mqswr"><span class="c21">REPAIR</span></h4><p class="c3"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sendo </span><span class="c9">i </span><span>o</span><span>&nbsp;identificador do nodo que sofre o evento de REPAIR. Primeiramente, utiliza-se a fun&ccedil;&atilde;o &lsquo;release&rsquo; de API smlp para indicar ao simulador que </span><span>nodo</span><span>&nbsp;se recuperou. Ent&atilde;o informa-se em log que id de nodo e o tempo de recupera&ccedil;&atilde;o, agenda-se evento </span><span>TEST</span><span>&nbsp;para tempo 30.0 ap&oacute;s tempo atual de simula&ccedil;&atilde;o. Finalmente, chama-se fun&ccedil;&atilde;o </span><span>&lsquo;inicializaNovoEvento()&rsquo;,</span><span>&nbsp;atualizando as informa&ccedil;&otilde;es de estrutura </span><span class="c9">tevento</span><span class="c12">&nbsp;da mesma forma previamente descrita, alterando-se apenas o tipo do evento (REPAIR).</span></p><p class="c3"><span class="c12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assim, a l&oacute;gica para REPAIR &eacute; completa, indo para o pr&oacute;ximo evento programado.</span></p><h4 class="c19" id="h.w6trksd7xq5s"><span>TEST</span></h4><p class="c3 c13"><span>Sendo </span><span class="c9">i </span><span>o</span><span class="c12">&nbsp;identificador do nodo que sofre o evento de TEST.</span></p><p class="c3 c13"><span>Primeiramente, verifica-se se </span><span>nodo</span><span>&nbsp;</span><span class="c9">i</span><span class="c12">&nbsp;est&aacute; CORRETO, caso contr&aacute;rio o teste &eacute; abortado.</span></p><p class="c3 c13"><span>Ap&oacute;s isso, itera-se sobre o vetor de testes </span><span class="c9">i,</span><span>&nbsp;testando cada um dos nodos que foram previamente estipulados atrav&eacute;s da funda&ccedil;&atilde;o </span><span>&lsquo;testarNodo()&rsquo;.</span><span>&nbsp;Neste momento, cada um dos testes realizados &eacute; contabilizado em estrutura </span><span class="c9">tevento</span><span>,</span><span class="c12">&nbsp;contabilizando a quantidade de testes at&eacute; o diagn&oacute;stico.</span></p><p class="c3 c13"><span>Em </span><span>&lsquo;testarNodo()&rsquo;</span><span>&nbsp;nodo </span><span class="c9">i</span><span>&nbsp;efetuar&aacute; testes sobre o nodo </span><span class="c9">j</span><span class="c12">&nbsp;de modo que:</span></p><p class="c2 c13"><span class="c12"></span></p><ul class="c11 lst-kix_l8uuvtic5ori-0 start"><li class="c3 c15 c16 li-bullet-0"><span>Estando </span><span class="c9">j</span><span class="c12">&nbsp;CORRETO:</span></li></ul><ul class="c11 lst-kix_l8uuvtic5ori-1 start"><li class="c3 c7 c15 li-bullet-0"><span>Se </span><span class="c9">j</span><span>&nbsp;conste</span><span>&nbsp;como DESCONHECIDO em Vector State de </span><span class="c9">i</span><span class="c12">, atualiza-se sua entrada para CORRETO.</span></li></ul><p class="c2 c7"><span class="c12"></span></p><ul class="c11 lst-kix_l8uuvtic5ori-1"><li class="c3 c7 c15 li-bullet-0"><span>Se </span><span class="c9">j</span><span>&nbsp;conste</span><span>&nbsp;como FALHO em Vector State de </span><span class="c9">i</span><span>, atualiza-se sua entrada para CORRETO (somando-se em 1 a entrada). Novo evento foi encontrado, chamando-se as fun&ccedil;&otilde;es </span><span>&lsquo;identificaEvento()&rsquo;</span><span>&nbsp;para atualizar diagn&oacute;stico em estrutura </span><span>tevent</span><span>&nbsp;e </span><span>&lsquo;</span><span>defineTestes()&rsquo;</span><span class="c9">&nbsp;</span><span>para atualiza lista de testes de </span><span class="c9">i</span><span class="c12">.</span></li></ul><p class="c2 c7"><span class="c12"></span></p><ul class="c11 lst-kix_l8uuvtic5ori-1"><li class="c3 c7 c15 li-bullet-0"><span>Finalmente, recupera-se todas as entradas &nbsp;de Vector State de </span><span class="c9">j</span><span>&nbsp;para </span><span class="c9">i</span><span>, de forma que a cada novidade encontrada (eventos) chamam-se as fun&ccedil;&otilde;es </span><span>&lsquo;identificaEvento()&rsquo;</span><span>&nbsp;e </span><span>&lsquo;defineTestes()&rsquo;.</span></li></ul><p class="c2 c7"><span class="c12"></span></p><ul class="c11 lst-kix_l8uuvtic5ori-0"><li class="c3 c15 c16 li-bullet-0"><span>Estando </span><span class="c9">j</span><span class="c12">&nbsp;FALHO:</span></li></ul><ul class="c11 lst-kix_l8uuvtic5ori-1 start"><li class="c3 c7 c15 li-bullet-0"><span>Se </span><span class="c9">j</span><span>&nbsp;conste</span><span>&nbsp;como DESCONHECIDO em </span><span>Vector</span><span>&nbsp;State </span><span>de </span><span class="c9">i</span><span>,</span><span>&nbsp;atualiza-se sua entrada para FALHO. Definindo-se assim um novo evento, chamando-se as fun&ccedil;&otilde;es </span><span>&lsquo;identificaEvento()&rsquo;</span><span>&nbsp;e </span><span>&lsquo;defineTestes()&rsquo;.</span></li></ul><p class="c2 c7"><span class="c12"></span></p><ul class="c11 lst-kix_l8uuvtic5ori-1"><li class="c3 c7 c15 li-bullet-0"><span>Se </span><span class="c9">j</span><span>&nbsp;consta</span><span>&nbsp;como CORRETO em </span><span>Vector</span><span>&nbsp;State </span><span>de </span><span class="c9">i</span><span>,</span><span>&nbsp;atualiza-se sua entrada para FALHO (somando-se 1 a entrada). Definindo-se assim um novo evento, chamando-se as fun&ccedil;&otilde;es </span><span>&lsquo;identificaEvento()&rsquo;</span><span>&nbsp;e </span><span>&lsquo;defineTestes()&rsquo;.</span></li></ul><p class="c2 c16"><span class="c12"></span></p><p class="c3"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quanto &agrave; fun&ccedil;&atilde;o </span><span>&lsquo;identificaEvento()&rsquo;,</span><span>&nbsp;ela ir&aacute; verificar se evento sinalizado corresponde ao que est&aacute; sendo atualmente diagnosticado. Caso afirmativo, atualizando vetor de &lsquo;alertados&rsquo; para o nodo </span><span class="c9">i</span><span>, indicando que o </span><span>nodo</span><span>&nbsp;correto </span><span class="c9">i</span><span>&nbsp;est&aacute;</span><span class="c12">&nbsp;a par do evento que est&aacute; sendo diagnosticado. Nela, verifica-se se todos os nodos corretos est&atilde;o a par do evento diagnosticado, caso todos estejam, imprime-se em log as informa&ccedil;&otilde;es correspondentes ao diagn&oacute;stico do evento (quantidade de rodadas, quantidade de testes, tempo de in&iacute;cio e fim de diagn&oacute;stico, nodo que sofreu evento e tipo de evento), e sinaliza-se que evento foi devidamente diagnosticado (diagnosticando = 0).</span></p><p class="c3"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quanto a fun&ccedil;&atilde;o </span><span>&lsquo;defineTestes()&rsquo;,</span><span>&nbsp;ela &eacute; a mesma que foi previamente definida em </span><span class="c18">Inicializa&ccedil;&otilde;es de Simula&ccedil;&atilde;o</span><span class="c12">.</span></p><p class="c2"><span class="c12"></span></p><p class="c3 c13"><span>Ap&oacute;s o nodo </span><span class="c9">i</span><span>&nbsp;realizar</span><span>&nbsp;os testes em toda sua lista de </span><span>testados,</span><span>&nbsp;verifica-se se existe um evento sendo diagnosticado, caso positivo, indica em vetor </span><span>rodada_completa</span><span>&nbsp;de </span><span class="c9">tevento</span><span>&nbsp;que nodo </span><span class="c9">i</span><span>&nbsp;completou sua bateria de testes em rodada atual. Verifica-se ent&atilde;o se todos os &nbsp;nodos corretos tamb&eacute;m completaram suas baterias de testes nesta rodada, caso afirmativo, incrementa-se o contador de rodadas de diagn&oacute;stico da estrutura </span><span class="c9">tevento</span><span>, reinicializando vetor </span><span>rodada_completa.</span></p><p class="c3 c13"><span>Finalmente, imprime-se o estado do Vector State do nodo </span><span class="c9">i</span><span>&nbsp;ap&oacute;s todos os testes e aguenta-se um novo evento do tipo TEST para o nodo </span><span class="c9">i</span><span>&nbsp;para tempo 30.0 ap&oacute;s tempo atual.</span></p></body></html>